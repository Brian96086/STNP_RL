# -*- coding: utf-8 -*-
"""2D_iclr2022_SIR_NP_LIG_heldout.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uBHJpKv6m3l356qoyajxyf2bRBM9VETY
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import torch
import matplotlib.pyplot as plt
# %matplotlib inline
import torch.nn as nn
import time
import argparse
import os
from config import cfg 
from src.seir import build_dataset
from src.dcrnn import DCRNNModel
from utils.agents.DQN import DQN
from utils.env.environment import Game
from engine import test, train, train_DQN,calculate_score, mae_plot, MAE, score_plot, select_data, MAE_MX
import utils 


# device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

device = torch.device("cpu")

def main(args):
    num_simulations = cfg.SIMULATOR.num_simulations
    seir_data = build_dataset(cfg)
    [beta_epsilon_all, beta_epsilon_train, beta_epsilon_val, beta_epsilon_test] =  seir_data[0]
    [x_all, yall_set, y_all], [x_val, yval_set, y_val], [x_test, ytest_set, y_test] = seir_data[1:]


    np.random.seed(3)
    mask_init = np.zeros(len(beta_epsilon_all))
    mask_init[:2] = 1
    mask_init[-2:] = 1

    np.random.shuffle(mask_init)
    selected_beta_epsilon = beta_epsilon_all[mask_init.astype('bool')]
    x_train_init = np.repeat(selected_beta_epsilon,num_simulations,axis =0)

    selected_y = yall_set[mask_init.astype('bool')]
    y_train_init = selected_y.reshape(selected_y.shape[0]*selected_y.shape[1],selected_y.shape[2])

    r_dim = cfg.MODEL.r_dim
    z_dim = cfg.MODEL.z_dim #8
    x_dim = cfg.MODEL.x_dim #
    y_dim = cfg.MODEL.y_dim #50
    N = cfg.SIMULATOR.population #population

    ypred_allset = []
    ypred_testset = []
    mae_allset = []
    maemetrix_allset = []
    mae_testset = []
    score_set = []
    mask_set = []

    for seed in range(1,2): #3
        np.random.seed(seed)
        config = build_config_dict(cfg, num_actions=len(beta_epsilon_all))
        x_train,y_train = x_train_init, y_train_init
        #Stage 0: temp STNP model generates data 
        temp_model_num = 2
        temp_dcrnn = None
        data_path = "dcrnn{}_data.pt".format(temp_model_num)
        if(not os.path.exists(data_path)):
            temp_dcrnn = DCRNNModel(x_dim, y_dim, r_dim, z_dim, device=device).to(device)
            temp_opt = torch.optim.Adam(temp_dcrnn.parameters(), cfg.MODEL.lr) #1e-3
            train_losses, val_losses, test_losses, z_mu, z_logvar, scenario_dict = train(
                    temp_dcrnn, temp_opt, cfg, int(cfg.TRAIN.stnp_epoch/5) ,x_train,
                    y_train,x_val, y_val, x_test, y_test,cfg.TRAIN.n_display, cfg.TRAIN.patience,
                    beta_epsilon_all=beta_epsilon_all
            )
            scenario_dict["mask"] = mask_init
            torch.save(scenario_dict, data_path)
        else:
            scenario_dict = torch.load(data_path)
            
        



        # np.save('y_all.npy',y_all)
        # np.save('y_test.npy',y_test)
        env = Game(cfg = cfg, dcrnn = temp_dcrnn,action_space = beta_epsilon_all, scenario_dict = scenario_dict, dataset_idx = 0)
        dqn = DQN(config, cfg, env, mask_init)
        for i in range(300):
            env = Game(cfg = cfg, dcrnn = temp_dcrnn,action_space = beta_epsilon_all, scenario_dict = scenario_dict, dataset_idx = i)
            dqn.env = env
            train_DQN(dqn, temp_dcrnn, beta_epsilon_all, scenarios = scenario_dict, config=config, cfg=cfg, episodes = cfg.TRAIN.episode)
        checkpoint_path = "results/dqn_ckpt_{i}.pth".format(i)
        if(i%20):
            torch.save({
                'model': dqn.q_network_local.state_dict(),
                'optimizer': dqn.q_network_optimizer.state_dict(),
                #'epoch': epoch,
                'config': cfg,
                #'loss': loss_list,
                #'val_mae': val_mae_list
            }, checkpoint_path)
        exit()


        


        y_pred_test_list = []
        y_pred_all_list = []
        all_mae_matrix_list = []
        all_mae_list = []
        test_mae_list = []
        score_list = []
        mask_list = []
        # selected_mask = init()
        selected_mask = np.copy(mask_init)

        
        #Stage1: Let dqn select data for dcrnn
        dcrnn = DCRNNModel(x_dim, y_dim, r_dim, z_dim, device=device).to(device)
        opt = torch.optim.Adam(dcrnn.parameters(), cfg.MODEL.lr) #1e-3
        
        for i in range(cfg.TRAIN.train_iter): #8
            # print('selected_mask:', selected_mask)
            print('i = {}, x_train shape = {}, y_train shape = {}, '.format(i, x_train.shape, y_train.shape))
            mask_list.append(np.copy(selected_mask))

            train_losses, val_losses, test_losses, z_mu, z_logvar = train(
                dcrnn, opt, cfg, cfg.TRAIN.stnp_epoch ,x_train,
                y_train,x_val, y_val, x_test, y_test,cfg.TRAIN.n_display, cfg.TRAIN.patience,
            ) #20000, 5000
            start_time = time.time()
            y_pred_test = test(dcrnn, torch.from_numpy(x_train).float(),torch.from_numpy(y_train).float(),
                            torch.from_numpy(x_test).float(), cfg.MODEL.z_dim)
            end_time = time.time()
            print('test time on train set = {}'.format(end_time - start_time))
            y_pred_test_list.append(y_pred_test)

            test_mae = N * MAE(torch.from_numpy(y_pred_test).float(),torch.from_numpy(y_test).float())/100
            test_mae_list.append(test_mae.item())
            print('Test MAE:',test_mae.item())

            start_time = time.time()
            y_pred_all = test(dcrnn, torch.from_numpy(x_train).float(),torch.from_numpy(y_train).float(),
                            torch.from_numpy(x_all).float(),cfg.MODEL.z_dim)
            y_pred_all_list.append(y_pred_all)
            mae_matrix, mae = MAE_MX(y_pred_all, y_all)
            end_time = time.time()
            print('test time on all = {}'.format(end_time - start_time))
        
            all_mae_matrix_list.append(mae_matrix)
            all_mae_list.append(mae)
            print('All MAE:',mae)
            mae_plot(mae_matrix, selected_mask,seed,i)

            start_time = time.time()
            score_array = calculate_score(cfg, dcrnn, x_train, y_train, beta_epsilon_all)
            score_array = (score_array - np.min(score_array))/(np.max(score_array) - np.min(score_array))
            end_time = time.time()
            print('score calculation = {}'.format(end_time - start_time))
            
            score_list.append(score_array)
            score_plot(score_array, selected_mask, seed, i)

            start_time = time.time()
            x_train, y_train, selected_mask = select_data(cfg, x_train, y_train, beta_epsilon_all, yall_set, score_array, selected_mask)
            end_time = time.time()
            print('data selection = {}'.format(end_time - start_time))

        y_pred_all_arr = np.stack(y_pred_all_list,0)
        y_pred_test_arr = np.stack(y_pred_test_list,0)
        all_mae_matrix_arr = np.stack(all_mae_matrix_list,0)
        all_mae_arr = np.stack(all_mae_list,0)
        test_mae_arr = np.stack(test_mae_list,0)
        score_arr = np.stack(score_list,0)
        mask_arr = np.stack(mask_list,0)

        ypred_allset.append(y_pred_all_arr)
        ypred_testset.append(y_pred_test_arr)
        maemetrix_allset.append(all_mae_matrix_arr)
        mae_allset.append(all_mae_arr)
        mae_testset.append(test_mae_arr)
        score_set.append(score_arr)
        mask_set.append(mask_arr)

    ypred_allarr = np.stack(ypred_allset,0)
    ypred_testarr = np.stack(ypred_testset,0) 
    maemetrix_allarr = np.stack(maemetrix_allset,0) 
    mae_allarr = np.stack(mae_allset,0)
    mae_testarr = np.stack(mae_testset,0)
    score_arr = np.stack(score_set,0)
    mask_arr = np.stack(mask_set,0)

    # np.save('mae_testarr.npy',mae_testarr)
    # np.save('mae_allarr.npy',mae_allarr)
    # np.save('maemetrix_allarr.npy',maemetrix_allarr)

    # np.save('score_arr.npy',score_arr)
    # np.save('mask_arr.npy',mask_arr)

    # np.save('y_pred_all_arr.npy',ypred_allarr)
    # np.save('y_pred_test_arr.npy',ypred_testarr)

    # np.save('y_all.npy',y_all)
    # np.save('y_test.npy',y_test)

class Config(object):
    """Object to hold the config requirements for an agent/game"""
    def __init__(self):
        self.seed = None
        self.environment = None
        self.requirements_to_solve_game = None
        self.num_episodes_to_run = None
        self.file_to_save_data_results = None
        self.file_to_save_results_graph = None
        self.runs_per_agent = None
        self.visualise_overall_results = None
        self.visualise_individual_results = None
        self.hyperparameters = None
        self.use_GPU = None
        self.overwrite_existing_results_file = None
        self.save_model = False
        self.standard_deviation_results = 1.0
        self.randomise_random_seed = True
        self.show_solution_score = False
        self.debug_mode = False

def build_config_dict(cfg, num_actions):

    config = Config()
    config.seed = 1
    config.num_episodes_to_run = cfg.TRAIN.episode
    config.file_to_save_data_results = "results/"
    config.file_to_save_results_graph = "results/"
    config.show_solution_score = False
    config.visualise_individual_results = False
    config.visualise_overall_agent_results = True
    config.standard_deviation_results = 1.0
    config.runs_per_agent = 1
    config.use_GPU = False
    config.overwrite_existing_results_file = False
    config.randomise_random_seed = True
    config.save_model = True
    config.action_size = num_actions
    config.state_size = 100

    config.hyperparameters = {
        "learning_rate": cfg.TRAIN.dqn_lr,
        "batch_size": cfg.TRAIN.batch_size,
        "buffer_size": cfg.TRAIN.buffer_size,
        "epsilon": cfg.TRAIN.epsilon,
        "epsilon_decay_rate_denominator": cfg.TRAIN.epsilon_decay_rate_denominator,
        "discount_rate": cfg.TRAIN.discount_rate,
        "tau": cfg.TRAIN.tau,
        "alpha_prioritised_replay": cfg.TRAIN.alpha_prioritised_replay,
        "beta_prioritised_replay": cfg.TRAIN.beta_prioritised_replay,
        "incremental_td_error": cfg.TRAIN.incremental_td_error,
        "update_every_n_steps": cfg.TRAIN.update_every_n_steps,
        "linear_hidden_units": cfg.TRAIN.linear_hidden_units,
        "final_layer_activation": cfg.TRAIN.final_layer_activation,
        "batch_norm": cfg.TRAIN.batch_norm,
        "gradient_clipping_norm": cfg.TRAIN.gradient_clipping_norm,
        "learning_iterations": cfg.TRAIN.learning_iterations,
        "clip_rewards": cfg.TRAIN.clip_rewards,
    }
    return config

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="STNP network with RL"
    )
    parser.add_argument(
        "--cfg",
        default="config/config.yaml",
        metavar="FILE",
        help="path to config file",
        type=str,
    )

    args = parser.parse_args()
    print(f'args cfg = {args.cfg}')
    cfg.merge_from_file(args.cfg)
    
    cfg.DIR.output_dir = os.path.join(cfg.DIR.snapshot, cfg.DIR.exp)
    if not os.path.exists(cfg.DIR.output_dir):
        os.mkdir(cfg.DIR.output_dir)    

    cfg.TRAIN.resume = os.path.join(cfg.DIR.output_dir, cfg.TRAIN.resume)
    cfg.VAL.resume = os.path.join(cfg.DIR.output_dir, cfg.VAL.resume)

    with open(os.path.join(cfg.DIR.output_dir, 'config.yaml'), 'w') as f:
        f.write("{}".format(cfg))

    main(cfg)
