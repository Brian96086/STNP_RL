# -*- coding: utf-8 -*-
"""2D_iclr2022_SIR_NP_LIG_heldout.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uBHJpKv6m3l356qoyajxyf2bRBM9VETY
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import torch
import matplotlib.pyplot as plt
# %matplotlib inline
import torch.nn as nn
import time
import argparse
import os
from config import cfg 
from src.seir import build_dataset
from src.dcrnn import DCRNNModel
from engine import test, train, calculate_score, mae_plot, MAE, score_plot, select_data, MAE_MX


# device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

device = torch.device("cpu")

def main(args):
    num_simulations = cfg.SIMULATOR.num_simulations
    seir_data = build_dataset(cfg)
    [beta_epsilon_all, beta_epsilon_train, beta_epsilon_val, beta_epsilon_test] =  seir_data[0]
    [x_all, yall_set, y_all], [x_val, yval_set, y_val], [x_test, ytest_set, y_test] = seir_data[1:]


    np.random.seed(3)
    mask_init = np.zeros(len(beta_epsilon_all))
    mask_init[:2] = 1

    np.random.shuffle(mask_init)
    selected_beta_epsilon = beta_epsilon_all[mask_init.astype('bool')]
    x_train_init = np.repeat(selected_beta_epsilon,num_simulations,axis =0)

    selected_y = yall_set[mask_init.astype('bool')]
    y_train_init = selected_y.reshape(selected_y.shape[0]*selected_y.shape[1],selected_y.shape[2])

    r_dim = cfg.MODEL.r_dim
    z_dim = cfg.MODEL.z_dim #8
    x_dim = cfg.MODEL.x_dim #
    y_dim = cfg.MODEL.y_dim #50
    N = cfg.SIMULATOR.population #population

    ypred_allset = []
    ypred_testset = []
    mae_allset = []
    maemetrix_allset = []
    mae_testset = []
    score_set = []
    mask_set = []

    for seed in range(1,3): #3
        np.random.seed(seed)
        dcrnn = DCRNNModel(x_dim, y_dim, r_dim, z_dim, device=device).to(device)
        opt = torch.optim.Adam(dcrnn.parameters(), cfg.MODEL.lr) #1e-3

        y_pred_test_list = []
        y_pred_all_list = []
        all_mae_matrix_list = []
        all_mae_list = []
        test_mae_list = []
        score_list = []
        mask_list = []

        x_train,y_train = x_train_init, y_train_init
        # selected_mask = init()
        selected_mask = np.copy(mask_init)
        #import ipdb;ipdb.set_trace()
        
        for i in range(cfg.TRAIN.train_iter): #8
            # print('selected_mask:', selected_mask)
            print('i = {}, x_train shape = {}, y_train shape = {}, '.format(i, x_train.shape, y_train.shape))
            mask_list.append(np.copy(selected_mask))

            start_time = time.time()
            train_losses, val_losses, test_losses, z_mu, z_logvar = train(
                dcrnn, opt, cfg, cfg.TRAIN.stnp_epoch ,x_train,
                y_train,x_val, y_val, x_test, y_test,cfg.TRAIN.n_display, cfg.TRAIN.patience,
            ) #20000, 5000
            end_time = time.time()
            print('train time = {}'.format(end_time - start_time))

            start_time = time.time()
            y_pred_test = test(dcrnn, torch.from_numpy(x_train).float(),torch.from_numpy(y_train).float(),
                            torch.from_numpy(x_test).float(), cfg.MODEL.z_dim)
            end_time = time.time()
            print('test time on train set = {}'.format(end_time - start_time))
            y_pred_test_list.append(y_pred_test)

            test_mae = N * MAE(torch.from_numpy(y_pred_test).float(),torch.from_numpy(y_test).float())/100
            test_mae_list.append(test_mae.item())
            print('Test MAE:',test_mae.item())

            start_time = time.time()
            y_pred_all = test(dcrnn, torch.from_numpy(x_train).float(),torch.from_numpy(y_train).float(),
                            torch.from_numpy(x_all).float(),cfg.MODEL.z_dim)
            y_pred_all_list.append(y_pred_all)
            mae_matrix, mae = MAE_MX(y_pred_all, y_all)
            end_time = time.time()
            print('test time on all = {}'.format(end_time - start_time))
            
            
            all_mae_matrix_list.append(mae_matrix)
            all_mae_list.append(mae)
            print('All MAE:',mae)
            mae_plot(mae_matrix, selected_mask,seed,i)

            start_time = time.time()
            score_array = calculate_score(cfg, dcrnn, x_train, y_train, beta_epsilon_all)
            score_array = (score_array - np.min(score_array))/(np.max(score_array) - np.min(score_array))
            end_time = time.time()
            print('score calculation = {}'.format(end_time - start_time))
            
            score_list.append(score_array)
            score_plot(score_array, selected_mask, seed, i)

            start_time = time.time()
            x_train, y_train, selected_mask = select_data(x_train, y_train, beta_epsilon_all, yall_set, score_array, selected_mask)
            end_time = time.time()
            print('data selection = {}'.format(end_time - start_time))

        y_pred_all_arr = np.stack(y_pred_all_list,0)
        y_pred_test_arr = np.stack(y_pred_test_list,0)
        all_mae_matrix_arr = np.stack(all_mae_matrix_list,0)
        all_mae_arr = np.stack(all_mae_list,0)
        test_mae_arr = np.stack(test_mae_list,0)
        score_arr = np.stack(score_list,0)
        mask_arr = np.stack(mask_list,0)

        ypred_allset.append(y_pred_all_arr)
        ypred_testset.append(y_pred_test_arr)
        maemetrix_allset.append(all_mae_matrix_arr)
        mae_allset.append(all_mae_arr)
        mae_testset.append(test_mae_arr)
        score_set.append(score_arr)
        mask_set.append(mask_arr)

    ypred_allarr = np.stack(ypred_allset,0)
    ypred_testarr = np.stack(ypred_testset,0) 
    maemetrix_allarr = np.stack(maemetrix_allset,0) 
    mae_allarr = np.stack(mae_allset,0)
    mae_testarr = np.stack(mae_testset,0)
    score_arr = np.stack(score_set,0)
    mask_arr = np.stack(mask_set,0)

    # np.save('mae_testarr.npy',mae_testarr)
    # np.save('mae_allarr.npy',mae_allarr)
    # np.save('maemetrix_allarr.npy',maemetrix_allarr)

    # np.save('score_arr.npy',score_arr)
    # np.save('mask_arr.npy',mask_arr)

    # np.save('y_pred_all_arr.npy',ypred_allarr)
    # np.save('y_pred_test_arr.npy',ypred_testarr)

    # np.save('y_all.npy',y_all)
    # np.save('y_test.npy',y_test)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="STNP network with RL"
    )
    parser.add_argument(
        "--cfg",
        default="config/config.yaml",
        metavar="FILE",
        help="path to config file",
        type=str,
    )

    args = parser.parse_args()
    print(f'args cfg = {args.cfg}')
    cfg.merge_from_file(args.cfg)
    
    cfg.DIR.output_dir = os.path.join(cfg.DIR.snapshot, cfg.DIR.exp)
    if not os.path.exists(cfg.DIR.output_dir):
        os.mkdir(cfg.DIR.output_dir)    

    cfg.TRAIN.resume = os.path.join(cfg.DIR.output_dir, cfg.TRAIN.resume)
    cfg.VAL.resume = os.path.join(cfg.DIR.output_dir, cfg.VAL.resume)

    with open(os.path.join(cfg.DIR.output_dir, 'config.yaml'), 'w') as f:
        f.write("{}".format(cfg))

    main(cfg)

